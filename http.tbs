include "global.tbh"

const HTTP_TLS_BUFF_PAGES=39

dim http_start_called as boolean=false
dim http_methods(6) as string(7) = {"GET", "HEAD", "POST", "PUT", "DELETE", "PATCH"}
dim http_request_list as http_request_type
dim http_timer_count as word = 0
dim http_chunk_length as word = 0

declare sub http_failed(byref error_message as string)

sub http_start()
	
	if http_request_list.http_request_in_progress=true then
		http_stop()
		http_debugprint("Current HTTP request cancelled, starting new request.")
	end if
	if http_start_called=true then		
		exit sub
	else
		http_start_called=true
	end if	
	http_request_list.http_request_in_progress=false
	http_request_list.state=FREE
	http_request_list.socket = sock_get("HTT")
	
end sub

sub http_stop()

	if http_start_called=true then		
		http_request_list.state=FREE
		sock_release(http_request_list.socket)		
	end if
	http_start_called=false
	
end sub

sub http_proc_data()

	if http_start_called=false then		
		exit sub
	end if		
	if http_check_socket_list()=NG then
		exit sub
	end if 
	http_get_headers()
	http_get_content()

end sub

sub http_get_headers()

	if http_request_list.state<>REQUEST_SENT then
		exit sub
	end if
	http_timer_count=0
	dim http_reply, next_byte as string
	while http_request_list.state<>HTTP_HEADERS_PROCESSED 
		if http_request_list.ssl then
			sock.tlspeekdata(1)
			if sock.tlspeeklen = 0 then
				exit sub
			end if
		else 
			if sock.rxlen = 0 then
				exit sub
			end if			
		end if
		next_byte=http_get_data(1)
		if next_byte="\x0a" then
			if http_request_list.state=REQUEST_SENT then
				http_reply=left(http_reply,len(http_reply)-1)
				dim b1 as byte=instr(1,http_reply," ",1)
				dim b2 as byte=instr(1,http_reply," ",2)
				http_reply=mid(http_reply,b1+1,b2-b1-1)
				callback_http_response_code_arrival(http_reply)
				http_debugprint("Response code:" + http_reply)
				http_request_list.state=HTTP_RESPONSE_PROCESSED
				http_reply=""
			else if http_request_list.state=HTTP_RESPONSE_PROCESSED then
				dim header_type, header_value as string
				dim b as byte= instr(1,http_reply,": ",1)
				if b=0 then
					callback_http_headers_complete()
					http_debugprint("Headers Complete")
					http_request_list.state=HTTP_HEADERS_PROCESSED
					exit while
				end if
				header_type=left(http_reply,b-1)
				header_value=right(http_reply,len(http_reply)-b-1)
				header_value=left(header_value,len(header_value)-1)
				callback_http_header_arrival(header_type,header_value)
				http_debugprint("Header> " + header_type + "\t\tValue: " + header_value)
				http_parse_headers(header_type)
				http_parse_headers(header_value)
				if header_type="content-length" then
					http_request_list.remaining_response_content_length=val(header_value)
					http_chunk_length = http_request_list.remaining_response_content_length
				end if
				if header_type="transfer-encoding" then
					if header_value="chunked" then
						http_request_list.chunked=true
					end if
				end if
				http_reply=""
			end if
		else
			http_reply=http_reply+next_byte
		end if
	wend	
	
end sub

sub http_get_content() 
	
	if http_request_list.state<>HTTP_HEADERS_PROCESSED then
		exit sub
	end if
	http_timer_count=0
	if http_request_list.chunked=true and http_request_list.remaining_response_content_length=0  then
		http_debugprint("Chunk complete")
		http_get_chunk_length()
	end if
	if http_request_list.remaining_response_content_length=0 then
		http_request_list.chunked=false
		http_request_complete()
	end if	
	dim data as string
	if http_request_list.remaining_response_content_length>HTTP_MAX_DATA_LENGTH then
		data=http_get_data(HTTP_MAX_DATA_LENGTH)
	else
		data=http_get_data(http_request_list.remaining_response_content_length)
	end if
	if len(data) > 0 then
		http_debugprint(str(http_request_list.remaining_response_content_length) + "/" + str(http_chunk_length))
		http_request_list.remaining_response_content_length=http_request_list.remaining_response_content_length-len(data)
		callback_http_content_arrival(data)
		http_debugprint(data)
		if http_request_list.chunked=false then
			if http_request_list.remaining_response_content_length=0 or http_request_list.method=HTTP_HEAD then
				http_request_complete()
			end if	
		end if	
	end if
	
end sub

sub http_get_chunk_length()
	
	dim chunk_length,next_byte as string
	dim timeout as boolean = false
	while timeout <> true
		dim tmp as string(1) = http_get_data(1)
		if tmp = "\n" then
			if len(chunk_length) > 0 then
				exit while
			end if
		else
			if tmp <> "\r" then
				chunk_length=chunk_length+tmp
			end if
		end if
	wend
	chunk_length="&h"+chunk_length
	http_request_list.remaining_response_content_length=val(chunk_length)
	http_chunk_length = http_request_list.remaining_response_content_length
	
end sub

sub http_request_complete()

	http_request_list.state=FREE
	sock.close()
	sock.discard()
	http_request_list.http_request_in_progress=false 
	callback_http_request_complete()				

end sub

sub http_reset_socket()

	http_request_list.dns_request_in_progress=false
	http_request_list.http_request_in_progress=false
	http_request_list.state=FREE 
	
end sub

sub http_dns_query(url as string)
	
	dim is_ip_address as boolean=true
	dim b as byte
	while is_ip_address=true 
		for b=1 to len(url)
			dim s as string=mid(url,b,1)
			dim ascii as word=asc(s)
			if ascii>=46 and ascii<=57 then
			else
				is_ip_address=false
				exit for
			end if
		next b
		if is_ip_address=true then
			http_request_list.ip=url
			http_request_list.state=DNS_REQUEST_SENT
			http_request_list.dns_request_in_progress=false
			http_request_list.state=DNS_COMPLETE
			http_init_request_socket()
			exit sub
		end if
	wend
	http_request_list.dns_request_in_progress=true
	dns_connect(http_request_list.interface, HTTP_DNS_SERVER, 0)
	dns_query(http_get_domain_name(url))
	http_request_list.state=DNS_REQUEST_SENT
		
end sub

sub http_proc_timer()

	if http_start_called=false then		
		exit sub
	end if
	http_check_dns_queue()
	if http_request_list.state > FREE then
		http_timer_count = http_timer_count + 1
		if http_timer_count > HTTP_TIMEOUT then
			http_failed("Timeout")
		end if
	end if
	
	
end sub

function http_get_domain_name(url as string) as string
'Returns the domain name section of a given URL
	
	dim b as byte
	if left(url, 4)="http" then
		b=instr(1,url,"/",2)
		url=right(url,len(url)-b)
	end if	
	b=instr(1,url,"/",1)
	http_get_domain_name=left(url,b-1)	
	b=instr(1,url,":",1)
	if b>0 then
		dim port_segment as string=right(url,len(url)-b)
		http_get_domain_name=left(url,b-1)
		b=instr(1,port_segment,"/",1)
		if b>0 then
			port_segment=left(port_segment,b-1)
		end if
		http_request_list.port=port_segment
	end if
	http_request_list.domain_name=http_get_domain_name
		
end function

function http_get_path(url as string) as string
'Returns the path section of a given URL

	dim b as byte=instr(1,url,"/",3)
	http_get_path=right(url,len(url)-b+1)
		
end function

sub http_init_request_socket()
	dim i as word
	if http_request_list.txbuffrq=0 then
		http_request_list.txbuffrq=2
	end if
	if http_request_list.rxbuffrq=0 then
		http_request_list.rxbuffrq=2
	end if 
	sock.num=http_request_list.socket
	sock.connectiontout=HTTP_TIMEOUT
	sock.targetip=http_request_list.ip
	sock.protocol=PL_SOCK_PROTOCOL_TCP
	sock.inconmode= PL_SOCK_INCONMODE_ANY_IP_ANY_PORT
	sock.targetport=http_request_list.port
	sock.allowedinterfaces = sock.availableinterfaces	
	sock.targetinterface=http_request_list.interface
	if sock.txbuffrq(http_request_list.txbuffrq) <> http_request_list.txbuffrq then
		http_failed("Not enough space in TX buffer")
		exit sub
	end if
	if sock.rxbuffrq(http_request_list.rxbuffrq) <> http_request_list.rxbuffrq  then
		http_failed("Not enough space in RX buffer")
		exit sub
	end if
	sys.buffalloc()	 
	if http_request_list.ssl=true then
		sock.tlsdeinit()
#if PLATFORM_ID<>WM2000
		sock.tlsbuffrq(HTTP_TLS_BUFF_PAGES)
#endif
		sys.buffalloc
		callback_http_open_romfile()
		if sock.tlsinit(romfile.offset)<>PL_TLS_SUCCESS then
			http_failed("Error loading certificate")
			exit sub
		end if
		sock.rxclear()
		sock.txclear()
	end if	
	i=sys.timercount
	sock.discard()
	sock.connect()

end sub

sub http_get_ip_and_port(url as string)

	http_request_list.http_request_in_progress=true
	dim port as word = http_get_port(url)
	if left(url, 5)="https" then
		http_request_list.ssl=true
		if port=0 then
			http_request_list.port=443
		else
			http_request_list.port=port
		end if
	else
		http_request_list.ssl=false
		if port=0 then
			http_request_list.port=80
		else
			http_request_list.port=port
		end if
	end if
	http_dns_query(http_request_list.domain_name)	
	
end sub

function http_get_port(url as string) as word

	dim port_segment as string
	dim b as byte=instr(1,url,":",2)
	if b>0 then
		http_get_port=right(url,len(url)-b)
		b=instr(1,port_segment,"/",1)
		if b>0 then
			http_get_port=left(port_segment,b-1)
		end if
	else 
		http_get_port=0
	end if
		
end function

sub http_generate_request(byref url as string, method as HTTP_REQUEST_METHODS, byref data as string, byref content_type as string, request_length as dword, long_request as boolean)

	if content_type="" then
		content_type="text/plain"
	end if
	http_request_list.url=url
	http_request_list.method=method
	http_request_list.remaining_content_length=request_length
	if long_request=true then
		if method=HTTP_GET or method=HTTP_HEAD then
			http_request_list.request=http_methods(method) + " " + http_get_path(url) + "?" + data + " HTTP/1.1\x0d\x0aHost: " + http_get_domain_name(url) + "\x0d\x0aContent-Type: " + content_type + "\x0d\x0a\x0d\x0a" 
		else	
			http_request_list.request=http_methods(method) + " " + http_get_path(url) + " HTTP/1.1\x0d\x0aHost: " + http_get_domain_name(url) + "\x0d\x0aContent-Type: " + content_type + "\x0d\x0aContent-Length: " + str(request_length) + "\x0d\x0a\x0d\x0a"
		end if
	else
		if method=HTTP_GET or method=HTTP_HEAD then
			http_request_list.request=http_methods(method) + " " + http_get_path(url) + "?" + data + " HTTP/1.1\x0d\x0aHost: " + http_get_domain_name(url) + "\x0d\x0aContent-Type: " + content_type + "\x0d\x0a\x0d\x0a"
		else	
			http_request_list.request=http_methods(method) + " " + http_get_path(url) + " HTTP/1.1\x0d\x0aHost: " + http_get_domain_name(url) + "\x0d\x0aContent-Type: " + content_type + "\x0d\x0aContent-Length: " + str(len(data)) + "\x0d\x0a\x0d\x0a" + data
		end if
	end if
		
end sub

function http_request(method as HTTP_REQUEST_METHODS, byref url as string, interface as pl_sock_interfaces, byref data as string, byref content_type as string) as byte
	
	http_request=http_request_with_buffers(method,url,interface,data,content_type,2,2)
	
end function

function http_request_with_buffers(method as HTTP_REQUEST_METHODS, byref url as string, interface as pl_sock_interfaces, byref data as string, byref content_type as string, txbuffrq as byte, rxbuffrq as byte) as byte
'Sends an HTTP request of a maximum length of 255 bytes

	http_start()
	http_timer_count = 0
	http_generate_request(url, method, data, content_type, 0, false)
	http_request_with_buffers=http_request_list.socket
	http_request_list.interface=interface
	http_request_list.txbuffrq=txbuffrq
	http_request_list.rxbuffrq=rxbuffrq
	http_request_list.chunked=false
	if http_request_list.http_request_in_progress=false then
		http_get_ip_and_port(url)
	end if
	
end function

function http_request_long(method as HTTP_REQUEST_METHODS, byref url as string, interface as pl_sock_interfaces, request_length as dword, byref content_type as string) as byte
'Sends a HTTP request to the specified path on a specified domain name. 
	
	http_request_long=http_request_long_with_buffers(method,url,interface,request_length,content_type,2,2)
	
end function

function http_request_long_with_buffers(method as HTTP_REQUEST_METHODS, byref url as string, interface as pl_sock_interfaces, request_length as dword, byref content_type as string, txbuffrq as byte, rxbuffrq as byte) as byte
'Sends a HTTP request to the specified path on a specified domain name. 
	
	http_start()
	http_generate_request(url,method, "", content_type, request_length, true)
	http_request_long_with_buffers=http_request_list.socket
	http_request_list.interface=interface
	http_request_list.txbuffrq=txbuffrq
	http_request_list.rxbuffrq=rxbuffrq
	if http_request_list.http_request_in_progress=false then
		http_get_ip_and_port(url)
	end if
		
end function

sub http_dns_answer_acquired(return_type as en_dns_return_type, byref return_string as string)
	
	if(return_type=EN_DNS_RET_IP) then
		http_request_list.ip=ddstr(return_string)
	end if
	
end sub

sub http_dns_ok()
	
	http_request_list.dns_request_in_progress=false
	http_request_list.state=DNS_COMPLETE
	http_init_request_socket()
	http_check_dns_queue()

end sub

sub http_check_dns_queue()

	if http_request_list.http_request_in_progress=true then
		exit sub
	end if
	if http_request_list.state=DNS_NOT_COMPLETE then
		http_get_ip_and_port(http_request_list.url)
	end if		
	
end sub

sub http_debugprint(byref print_data as string) 
	
	#if HTTP_DEBUG_PRINT 
		sys.debugprint(HTTP_STAMP + left(print_data,HTTP_MAX_DATA_LENGTH) + HTTP_CR_LF)
	#endif

end sub


function http_send_post_data(data as string) as byte
	
	if http_check_socket_list()=NG then
		exit function
	end if
	if sock.txfree>255 then
		http_send_post_data=255
	else
		http_send_post_data=sock.txfree
	end if
	if http_request_list.remaining_content_length<=http_send_post_data then
		http_send_post_data=http_request_list.remaining_content_length
	end if	
	http_request_list.remaining_content_length=http_request_list.remaining_content_length-http_send_post_data
	data=left(data,http_send_post_data)
	http_set_data(data)
	sock.notifysent(0)
	sock.send()		
	
end function

sub http_set_data(data as string)

	if http_request_list.ssl=true then
		sock.tlssetdata(data)
	else
		sock.setdata(data)
	end if
	
end sub

function http_get_data(size as byte) as string

	if http_request_list.ssl=true then
		http_get_data=sock.tlsgetdata(size)
	else
		http_get_data=sock.getdata(size)
	end if
	
end function

function http_encode_url(unencoded_url as string) as string
 
	dim i, j, n as byte
	dim chr_hex as string
	for i = 1 to len(unencoded_url)
		n = asc(mid(unencoded_url,i,1))
		if n > 127 then
			sys.debugprint("Character out of range")
		else if (n >= 48 and n <= 57) or (n >= 65 and n <= 90) or (n >= 97 and n <= 122) then
			http_encode_url = http_encode_url + mid(unencoded_url,i,1)
		else
			chr_hex = hex(asc(mid(unencoded_url,i,1)))
			chr_hex=right(chr_hex,len(chr_hex)-2)
			for j = 0 to (len(chr_hex)/2)-1
			    http_encode_url = http_encode_url + "%" + mid(chr_hex ,(2*j) + 1,2)
			next j
		end if
	next
	
end function

function http_check_socket_list() as ok_ng
	
	http_check_socket_list=NG
	if http_request_list.socket=sock.num and sock.num<>255 then
		http_check_socket_list=ok
	end if	
	
end function

sub http_dns_failure()

	http_failed("DNS failure")	
	
end sub 

sub http_sock_state_update(newstatesimple as enum pl_sock_state_simple)

	if http_start_called=false then		
		exit sub
	end if	
	if http_check_socket_list()=NG then
		exit sub
	end if	
'	if newstatesimple=PL_SSTS_CLOSED then
'		if http_request_list.state >= REQUEST_SENT then
'			http_failed("Connection failure")
'		end if		
'	end if	
	if newstatesimple<>PL_SSTS_EST then
		exit sub
	else
		if http_request_list.ssl=true then
			select case sock.state
			case PL_SST_EST_AOPENED:
				dim domain as string = http_request_list.domain_name
				sock.tlshandshake(domain)
			case PL_TLS_EST:
				http_set_data(http_request_list.request)
				sock.send()
				if http_request_list.method=HTTP_POST and http_request_list.remaining_content_length>0 then
					callback_http_send_post_data(http_request_list.remaining_content_length)
				end if
			end select
		else	
			http_set_data(http_request_list.request)
			sock.send()
			if http_request_list.remaining_content_length>0 then
				callback_http_send_post_data(http_request_list.remaining_content_length)
			end if
		end if
	end if
	http_request_list.state=REQUEST_SENT	
	
end sub

sub http_on_sock_data_sent()

	if http_check_socket_list()=255 then
		exit sub
	end if
	if http_request_list.remaining_content_length>0 then
		callback_http_send_post_data(http_request_list.remaining_content_length)
	else
		callback_http_post_data_sent_ok()
		http_debugprint("HTTP Post Data Sent")
	end if
	
end sub

sub http_parse_headers(byref input_string as string)
	
	http_to_lower_case(input_string) 
	http_remove_leading_whitespace(input_string)

end sub

sub http_to_lower_case(byref input_string as string) 
	
	dim b as byte
	dim current_character as string(1)
	dim modified_string as string
	for b=1 to len(input_string)
		current_character = (mid(input_string,b,1))
		dim b as byte=asc(current_character)
		if asc(current_character)>64 and asc(current_character)<91 then
			current_character=chr(asc(current_character)+32)
		end if
		modified_string=modified_string+current_character
	next b
	input_string=modified_string

end sub

sub http_remove_leading_whitespace(byref input_string as string)

	if asc(left(input_string,1))=32 then
		input_string=right(input_string,len(input_string)-1)
	end if
	
end sub

sub http_failed(byref error_message as string)
	http_reset_socket()
	http_debugprint("Failed reason:" + error_message)
	callback_http_request_failed(error_message)
end sub